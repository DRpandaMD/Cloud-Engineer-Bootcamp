# Signals

[Home](/README.md)

Signals are used to emit notifications for processes to take action in response to often unpredictable events. These may be caused from within a process itself, or from external events such as other processes. Many signals are fatal and result in process termination. However, death sometimes can be averted if program designers decide to handle (subvert) certain termination signals. Furthermore, many signals are more benign and are just informative or request other kinds of actions. It is possible to send signals (including those that induce termination) from the command line using `kill`, `killall` and `pkill`.

You should be able to do the following:

* explain what signals are and how they are used

* discuss the available signals and types of signals available in Linux

* use `kill` `killall` and `pkill` to send signals from the command line


## What are signals

* oldest method of Inter-Process Communication (IPC)

* used to notify process about asynchronous events or exceptions

* asynchronous -- where the signal-receiving process may
  * not expect the event to occur
  * expect the event, but no know when it is most likely to occur 

* there are two paths to send a signal to a process
  * from the kernel to a user process, from an exception or programming error
  * from a user process with a sys-call to the kernel which will then send it to a user process -- what is interesting is that the process sending the signal can actually be the same as the one receiving it

## Types of Signals

* signals are used to handle two things
  * exceptions detected by hardware -- illegal memory reference
  * exceptions generated by the environment -- a premature death of a process from the terminal

The signals from SIGRTMIN on are termed real-time signals and are a relatively recent addition. They have no predefined purpose, and differ in some important ways from normal signals; they can be queued up and are handled in a FIFO (First In First Out) order.

### Available signals for a x86 architecture

| SIGNAL | VALUE | DEFAULT ACTION | POSIX? | MEANING |
| ------ | ----- | -------------- | ------ | ------- |
| SIGHUP         |  1    | Terminate  |   Yes  |  Hangup detected on controlling terminal or death of controlling process
| SIGINT         |  2    | Terminate  |   Yes  |   Interrupt from keyboard|
| SIGQUIT        |  3    | Core dump |    Yes |    Quit from keyboard|
| SIGILL         |  4    | Core dump  |   Yes  |   Illegal instruction|
| SIGTRAP        |  5    | Core dump |    No |   Trace/breakpoint trap for debugging|
| SIGABTR SIGIOT |     6    | Core dump |    Yes  |   Abnormal termination|
| SIGBUS    | 7|     Core dump |    Yes |    Bus error|
| SIGFPE|     8    | Core dump  |   Yes |    Floating point exception|
| SIGKILL    | 9    | Terminate|     Yes |    Kill signal (cannot be caught or ignored)|
| SIGUSR1|     10    | Terminate  |   Yes |    User-defined signal 1|
| SIGSEGV|     11    | Core dump  |   Yes |    Invalid memory reference|
| SIGUSR2    | 12    | Terminate  |   Yes |    User-defined signal 2|
| SIGPIPE|     13    | Terminate  |   Yes  |   Broken pipe: write to pipe with no readers|
| SIGALRM    | 14|     Terminate  |   Yes   |  Timer signal from alarm|
| SIGTERM|     15    | Terminate  |   Yes  |   Process termination|
| SIGSTKFLT    | 16|     Terminate   |  No   | Stack fault on math co-processor|
| SIGCHLD|     17    | Ignore  |   Yes |    Child stopped or terminated|
| SIGCONT    | 18 |     Continue   |  Yes  |   Continue if stopped|
| SIGSTOP|     19    | Stop  |   Yes |    Stop process (can not be caught or ignored)|
| SIGTSTP|     20    | Stop   |  Yes |   Stop types at tty|
| SIGTTIN|     21    | Stop  |  Yes |    Background process requires tty input|
| SIGTTOU|     22    | Stop   |  Yes |    Background process requires tty output|
| SIGURG|     23    | Ignore |    No  |   Urgent condition on socket (4.2 BSD)|
| SIGXCPU|     24    | Core dump  |   Yes |    CPU time limit exceeded (4.2 BSD)|
| SIGXFSZ|     25    | Core dump   |  Yes |    File size limit exceeded (4.2 BSD)|
| SIGVTALRM    | 26|     Terminate |    No  |   Virtual alarm clock (4.2 BSD)|
| SIGPROF|     27    | Terminate |    No |    Profile alarm clock (4.2 BSD)|
| SIGWINCH|     | 28    Ignore |   No  |   Window resize signal (4.3 BSD, Sun)|
| SIGIO SIGPOLL    | 29   | Terminate  |   No  |   I/O now possible (4.2 BSD) (System V)|
| SIGPWR    | 30|     Terminate    | No  |   Power Failure (System V)|
| SIGSYS SIGUNUSED|     31  |  Terminate   |  No |   Bad System Called. Unused signal|


## kill

* a process cannot send a signal directly to another process it must use a sys-call to kernel to do it.

```bash
kill 1991
kill -9 1991
kill -SIGKILL 1991
```

* when a number is not give the default signal to send is `SIGTERM` -- useful when you want the process to try to die gracefully

* if that sig gets ignored, you just give it the 9 or `SIGKILL` to kill the process entierly with out waiting 

## killall and pkill

* `killall` kills all process with a give name

```bash
killall bash
killall -9 bash
killall -SIGKILL bash
```

* `pkill` sends a signal to a process using 

`pkill [-signal] [options] [pattern]`

* for example

`pkill -u libby foobar` will kill all of the user libby's processes with the name foobar

## Lab 4.1

There is a lab here, but the source code provided seemed to be locked down.

When I ran it, it didn't really do anything interesting other than just list how many times and which signals were used in the system.  I just compiled it on the gcloud client and ran it there.  I was too lazy to spin up a ubuntu image and install gcc on it.